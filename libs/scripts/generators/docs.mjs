#!/usr/bin/env node

/**
 * This file automatically generates the MDX docs for Storybook from any
 * markdown files in the '/docs' directory or any file added to the
 * 'includes' array.
 */

import {
  statSync,
  readdirSync,
  readFileSync,
  writeFileSync,
  existsSync,
  cpSync,
  mkdirSync,
  rmSync
} from 'fs';
import chokidar from 'chokidar';
import * as path from 'path';
import camelCase from 'camelcase';
// import config from '../../components/package.json' assert { type: 'json' };

// Replaces the old CJS __dirname with a variable mapped to the project root
const componentsProject = path.dirname(path.resolve('../components/package.json'));
// const versionNumber = config.version;

// Includes and excludes should be relative to the root of the project
export const includes = ['../../docs'];
const excludes = ['.DS_Store', 'database.dbml'];

const sbRoot = path.resolve(componentsProject, '.storybook');
const output = path.resolve(sbRoot, '.docs');

// If the output directory doesn't exist, create it
if (!existsSync(output)) {
  mkdirSync(output, { recursive: true });
}

const rootReadMe = `
# What's this?

This folder is where the MDX versions of the files in the docs folder are stored.
It is automatically generated by the 'scripts/generate-docs.mjs' script and can safely
be ignored.
`;

const formatName = (fileName) => {
  let prefix = '';
  let outputName = fileName;
  if (outputName.startsWith('adr-')) {
    const matcher = outputName.match(/adr-([0-9]{3})-([a-z-]+)+/);
    if (matcher) {
      [, prefix, outputName] = matcher;
      prefix = prefix.toUpperCase() + ': ';
    }
  }
  outputName = camelCase(outputName, { pascalCase: true })
    .replace(/([A-Z][a-z])/g, ' $1')
    .replace(/(\d)/g, ' $1')
    .trim();
  return `${prefix}${outputName}`;
};

const recurseDirectories = (file) => {
  if (excludes.includes(path.basename(file))) {
    return;
  }

  if (statSync(file).isDirectory()) {
    const dirs = readdirSync(file);
    return dirs.forEach((dir) => {
      // If the directory is the images folder, copy it to the output and return
      if (dir === 'images') {
        cpSync(path.join(file, dir), path.resolve(componentsProject, output, 'images'), {
          recursive: true
        });
        return;
      }
      recurseDirectories(path.join(file, dir));
    });
  }

  // Get the file path from the repo root
  const filePath = path.resolve(componentsProject, file);
  const baseFileName = path.parse(filePath).name;
  console.log('Processing file: ', filePath);

  // Define the docs folder as the base to strip from the file path
  const docsFolder = path.resolve(componentsProject, '../../docs');
  let dirName = path.parse(filePath).dir.replace(docsFolder, '').trim();
  if (dirName.startsWith(path.sep)) {
    dirName = dirName.slice(1);
  }

  // Convert any remaining path separators to dashes
  let directory = dirName.split(path.sep).join('-').replace(/\s+/g, '-').toLowerCase();
  if (directory === 'docs' || directory === '') {
    directory = '';
  }

  const outputDir = path.resolve(componentsProject, output, directory);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  const fileContents = readFileSync(filePath, 'utf8');

  let pageTitle = baseFileName;
  pageTitle = formatName(pageTitle);
  if (pageTitle === 'Readme') pageTitle = 'Introduction';
  if (pageTitle === 'Index') pageTitle = 'Introduction';
  const pagePath = `${directory ? formatName(directory) + '/' : ''}`;
  let convertedContent = `{/* This file is automatically generated by the 'scripts/generate-docs.mjs' script. Do not edit it directly. */}\n\n<Meta title="${pagePath}${pageTitle}" />\n\n`;

  fileContents.split('\n').forEach((line) => {
    if (line === '' && convertedContent.endsWith('\n\n')) {
      return;
    }
    if (line.startsWith('#import')) {
      convertedContent = line.replace('#', '') + '\n\n' + convertedContent;
      return;
    }
    const regex = /\[([\S ]+)\]\((.\/[a-z-/]+.md)\)/;
    if (regex.test(line)) {
      const [, , link] = line.match(regex);
      let convertedLink = link
        .replace(/\.\/(docs)?\/*/, '@temp@')
        .replace(/\//g, '-')
        .replace('.md', '--docs#top');
      if (!directory) {
        convertedLink = convertedLink.replace('@temp@', '?path=/story/docs-');
      } else {
        convertedLink = convertedLink.replace('@temp@', `?path=/story/docs-${directory}-`);
      }
      const newLine = line.replace(link, convertedLink);
      convertedContent += newLine + '\n';
    } else {
      convertedContent += line + '\n';
    }
  });

  let fileName = '';
  if (baseFileName === 'README.md') {
    fileName = 'introduction.mdx';
  } else {
    fileName = baseFileName.replace('_', '-').toLowerCase() + '.mdx';
  }
  // Output the file to the output folder
  writeFileSync(path.resolve(outputDir, fileName), convertedContent, 'utf8');
};

const updateStorybookLogo = () => {
  const logo = readFileSync(
    path.resolve(componentsProject, `${sbRoot}/jackanory-storybook-logo.svg`),
    'utf8'
  );
  writeFileSync(
    path.resolve(componentsProject, `${output}/images/jackanory-storybook-logo.svg`),
    logo,
    'utf8'
  );
};

const runGenerator = () => {
  // If the output directory exists, delete all files in it so we can start fresh
  if (existsSync(output)) {
    rmSync(output, { force: true, recursive: true });
  }
  mkdirSync(output, { recursive: true });
  // Create the root README file
  writeFileSync(path.resolve(componentsProject, output, 'README.md'), rootReadMe, 'utf8');

  // Process each directory listed in includes
  includes.map((d) => recurseDirectories(path.resolve(componentsProject, d)));

  // Update the Storybook logo
  updateStorybookLogo();
};

(function () {
  // Run the generator once to start with
  runGenerator();
  // If the script is called with '--watch' or '-w', watch for changes and re-run the generator
  if (process.argv.includes('--watch') || process.argv.includes('-w')) {
    chokidar
      .watch(includes.map((i) => path.resolve(i)), {
        ignored: /(^|[\/\\])\../,
        ignoreInitial: true
      })
      .on('ready', () => {
        console.log('Watching docs folder(s) for changes...');
      })
      .on('all', (event, changedPath) => {
        console.log(event, changedPath);
        runGenerator();
      });
  }
})();
