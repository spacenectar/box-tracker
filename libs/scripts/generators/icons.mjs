#! /usr/bin/env node

/**
 * This file automatically generates the icon components from the SVG files in
 * the 'projects/assets/icons' folder.
 */

import {
  statSync,
  readdirSync,
  readFileSync,
  writeFileSync,
  existsSync,
  mkdirSync,
  rmSync
} from 'fs';
import { join, resolve, basename, dirname } from 'path';
import camelCase from 'camelcase';
import prettier from 'prettier';
import chokidar from 'chokidar';

// Map __dirname to the project root using the location of webapp/package.json
const __dirname = dirname(resolve('../webapp/package.json'));

export const srcPath = resolve(__dirname, '../assets/icons');

const componentRootPath = resolve(__dirname, '../components/data-display/icon');
const componentLibPath = resolve(__dirname, componentRootPath, 'components');

const IconComponentTemplate = `import { SVGAttributes, forwardRef } from 'react';

export type Props = SVGAttributes<SVGElement>;

export const {*DISPLAY_NAME*} = forwardRef<SVGSVGElement, Props>(({
  fill = 'currentColor',
  ...props
}, ref) => {
  return ({*SVG_CONTENT*})
});

{*DISPLAY_NAME*}.displayName = '{*DISPLAY_NAME*}';

export default {*DISPLAY_NAME*};
`;

const rootReadMe = `
# THIS FOLDER IS AUTO-GENERATED

## DO NOT EDIT/DELETE OR ADD ANY FILES IN THIS FOLDER

All files in this folder are automatically generated by the
'scripts/icons.mjs' script.

If you want to add a new icon, add an SVG file with the icon name (in kebab-case)
to the 'projects/assets/icons' folder and run 'nx run scripts:generate-icons' to generate the new
icon component.

If you want to delete an icon, delete the SVG file from the 'projects/assets/icons' folder
and run 'nx run scripts:generate-icons' to delete the icon component.

If you want to edit an icon, edit the SVG file in the 'projects/assets/icons' folder and
run 'nx run scripts:generate-icons' to regenerate the icon component.
`;

const stripTagsAndContents = (content, tags) => {
  tags.forEach((tag) => {
    const regex = new RegExp(`<${tag}[^>]*>[\\s\\S]*?<\\/${tag}>`, 'gi');
    content = content.replace(regex, '');
  });
  return content;
};

// Convert an SVG file into a React component
const convertIcon = async (file) => {
  const name = basename(file, '.svg');

  let contents = readFileSync(file, 'utf8');
  // Remove XML declaration, comments, and DOCTYPE
  contents = contents
    .replace(/<\?xml[^>]+>/, '')
    .replace(/<!--[^>]+-->/g, '')
    .replace(/<!DOCTYPE[^>]+>/, '');

  // Strip out defs and style tags and their contents
  contents = stripTagsAndContents(contents, ['defs', 'style']);

  // Remove class attributes
  contents = contents.replace(/\sclass="[^"]+"/g, '');

  // Update the SVG tag with required attributes
  const svgStart = contents.indexOf('<svg');
  const svgEnd = contents.indexOf('>', svgStart);
  const svgAttributes = contents.slice(svgStart + 4, svgEnd);
  let newSvgAttributes = svgAttributes
    .replace(/fill="[^"]+"/, '')
    .replace(/class="[^"]+"/, '')
    .replace(/id="[^"]+"/, '')
    .replace(/data-name="[^"]+"/, '')
    .replace(/style="[^"]+"/, '');
  newSvgAttributes = newSvgAttributes
    .replace('xmlns:xlink', 'xmlnsXlink')
    .replace('xlink:href', 'xlinkHref')
    .replace('xml:space', 'xmlSpace');
  newSvgAttributes = newSvgAttributes.concat('\nfill={fill}\n{...props}\nref={ref}');
  contents = contents.replace(svgAttributes, newSvgAttributes);

  // Ensure all attribute names are camelCased for JSX compliance
  contents = contents.replace(/\s[a-z-]+=/g, (match) => {
    const attribute = match.trim();
    const camelCasedAttribute = camelCase(attribute);
    return ` ${camelCasedAttribute}`;
  });

  const output = IconComponentTemplate
    .replace('{*SVG_CONTENT*}', contents)
    .replace(/{\*DISPLAY_NAME\*}/g, camelCase(name, { pascalCase: true }))
    .replace('</svg>;', '</svg>');

  const cleanOutput = await prettier.format(output, {
    parser: 'flow',
    singleQuote: true
  });
  writeFileSync(join(componentLibPath, `${name}.tsx`), cleanOutput);
};

const processFiles = async (file) => {
  const stat = statSync(file);
  if (stat.isDirectory()) {
    throw new Error(
      'Subdirectories are not supported, please add your SVG files to the root of the icons folder'
    );
  } else if (stat.isFile() && file.endsWith('.svg')) {
    await convertIcon(file);
  }
};

const generateIndex = async (files) => {
  const index = files
    .map((file) => {
      const name = basename(file, '.svg');
      return `import ${camelCase(name, { pascalCase: true })} from './${name}';`;
    })
    .join('\n');

  let iconObjectTemplate = `const icons = {`;
  files.forEach((file) => {
    const name = camelCase(basename(file, '.svg'), { pascalCase: true });
    iconObjectTemplate += `\n  ${name.toLowerCase()}: ${name},`;
  });
  iconObjectTemplate += `\n};`;

  const fileContents = `${index}\n\n${iconObjectTemplate}\n\nexport default icons;`;
  const cleanOutput = await prettier.format(fileContents, {
    parser: 'typescript',
    singleQuote: true,
    trailingComma: 'none'
  });

  writeFileSync(join(componentLibPath, 'index.tsx'), cleanOutput);
};

const generateGallery = async (files) => {
  let galleryTemplate = `/**THIS FILE IS AUTOGENERATED, DO NOT EDIT**/\nimport { IconGallery, IconItem } from '@storybook/blocks';
import { Icon } from './index';
const Gallery = () => (
  <IconGallery>
`;
  files.forEach((file) => {
    const name = camelCase(basename(file, '.svg'), { pascalCase: true });
    galleryTemplate += `
    <IconItem name="${name}">
      <Icon use="${name.toLowerCase()}" />
    </IconItem>
`;
  });
  galleryTemplate += `  </IconGallery>
);
export default Gallery;`;
  const cleanOutput = await prettier.format(galleryTemplate, {
    parser: 'typescript',
    singleQuote: true,
    trailingComma: 'none'
  });
  writeFileSync(join(componentRootPath, 'gallery.tsx'), cleanOutput);
};

const runGenerator = async () => {
  const files = readdirSync(srcPath).filter((file) => file.endsWith('.svg'));
  if (existsSync(componentLibPath)) {
    rmSync(componentLibPath, { recursive: true, force: true });
  }
  mkdirSync(componentLibPath);
  writeFileSync(join(componentLibPath, 'README.md'), rootReadMe);
  await generateIndex(files);
  await generateGallery(files);
  await Promise.all(
    files.map(async (file) => {
      const filePath = join(srcPath, file);
      await processFiles(filePath);
    })
  );
};

(async () => {
  await runGenerator();
  if (process.argv.includes('--watch') || process.argv.includes('-w')) {
    chokidar
      .watch(resolve(srcPath), {
        ignored: /(^|[\/\\])\../,
        ignoreInitial: true
      })
      .on('ready', () => {
        console.log('Watching icons folder for changes...');
      })
      .on('all', async (event, path) => {
        console.log(event, path);
        await runGenerator();
      });
  }
})();
